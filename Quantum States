data Complex a = Complex a a

instance (Eq a) => Eq (Complex a) where
 (==) (Complex r1 i1) (Complex r2 i2) = (r1 == r2) && (i1 == i2)

instance (Show a) => Show (Complex a) where
 (show) (Complex r i) = (show r) ++ " " ++ (show i) ++ "i" 

--instance (Num a) => Num (Complex a) where
 --(*) (Complex r1 i1) (Complex r2 i2) = Complex (r1*r2) (i1*i2)
 --(+) (Complex r1 i1) (Complex r2 i2) = Complex (r1+r2) (i1+i2)

data QuantymState a = QuantymState a String

instance (Eq a) => Eq (QuantymState a) where
 (==) (QuantymState complex1 label1) (QuantymState complex2 label2) = (complex1 == complex2) && (label1 == label2) 

instance (Show a) => Show (QuantymState a) where
 (show) (QuantymState complex label) = (show complex) ++ " " ++ (show label) 

instance Functor QuantymState where
    fmap func (QuantymState complex label) = QuantymState (func complex) label



type Qubit a = [QuantymState a]

toList:: Qubit (Complex a) -> [Complex a]
toList qub = [x | (QuantymState x y) <- qub]

toLabelList::Qubit (Complex a) -> [String]
toLabelList qub = [ y | (QuantymState x y) <- qub]

fromList:: [Complex a]->[String]->Qubit (Complex a)
fromList com str = [(QuantymState x y) | x <- com, y <-str]

toPairList:: Qubit (Complex a)->[(Complex a,String)]
toPairList qub = [(com,str) | (QuantymState com str) <- qub]

fromPairList:: [(Complex a,String)] -> Qubit (Complex a)
fromPairList pairs = [ (QuantymState x y) | (x,y) <- pairs]

--scalarProduct:: Qubit (Complex a) ->Qubit (Complex a) -> a
--scalarProduct [] [] = 0
--scalarProduct ((QuantymState complex1 _) : xs) ((QuantymState complex2 _) : yx) = complex1 * complex2 + (scalarProduct xs ys)

-- To be continued...
